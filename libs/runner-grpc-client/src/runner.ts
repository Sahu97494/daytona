// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.2
//   protoc               v3.12.4
// source: runner.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire'
import type { CallContext, CallOptions } from 'nice-grpc-common'

export const protobufPackage = 'runner'

/** Health messages */
export interface HealthCheckRequest {}

export interface HealthCheckResponse {
  status: string
  version: string
}

/** Sandbox messages */
export interface CreateSandboxRequest {
  id: string
  fromVolumeId?: string | undefined
  userId: string
  image: string
  osUser: string
  cpuQuota: number
  gpuQuota: number
  memoryQuota: number
  storageQuota: number
  env: { [key: string]: string }
  registry?: Registry | undefined
  entrypoint: string[]
  volumes: Volume[]
}

export interface CreateSandboxRequest_EnvEntry {
  key: string
  value: string
}

export interface CreateSandboxResponse {
  sandboxId: string
}

export interface DestroySandboxRequest {
  sandboxId: string
}

export interface DestroySandboxResponse {
  message: string
}

export interface CreateSnapshotRequest {
  sandboxId: string
  registry?: Registry | undefined
  image: string
}

export interface CreateSnapshotResponse {
  message: string
}

export interface StartSandboxRequest {
  sandboxId: string
}

export interface StartSandboxResponse {
  message: string
}

export interface StopSandboxRequest {
  sandboxId: string
}

export interface StopSandboxResponse {
  message: string
}

export interface GetSandboxInfoRequest {
  sandboxId: string
}

export interface GetSandboxInfoResponse {
  state: string
  snapshotState: string
}

export interface RemoveDestroyedSandboxRequest {
  sandboxId: string
}

export interface RemoveDestroyedSandboxResponse {
  message: string
}

/** Image messages */
export interface Registry {
  url: string
  project?: string | undefined
  username?: string | undefined
  password?: string | undefined
}

export interface PullImageRequest {
  image: string
  registry?: Registry | undefined
}

export interface PullImageResponse {
  message: string
}

export interface BuildImageRequest {
  image?: string | undefined
  registry?: Registry | undefined
  dockerfile: string
  organizationId: string
  context: string[]
  pushToInternalRegistry?: boolean | undefined
}

export interface BuildImageResponse {
  message: string
}

export interface ImageExistsRequest {
  image: string
  includeLatest: boolean
}

export interface ImageExistsResponse {
  exists: boolean
}

export interface RemoveImageRequest {
  image: string
  force: boolean
}

export interface RemoveImageResponse {
  message: string
}

export interface BuildLogsRequest {
  imageRef: string
  follow: boolean
}

export interface BuildLogsResponse {
  data: Uint8Array
}

/** Add Volume message for CreateSandboxRequest */
export interface Volume {
  volumeId: string
  mountPath: string
}

function createBaseHealthCheckRequest(): HealthCheckRequest {
  return {}
}

export const HealthCheckRequest: MessageFns<HealthCheckRequest> = {
  encode(_: HealthCheckRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseHealthCheckRequest()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(_: any): HealthCheckRequest {
    return {}
  },

  toJSON(_: HealthCheckRequest): unknown {
    const obj: any = {}
    return obj
  },

  create<I extends Exact<DeepPartial<HealthCheckRequest>, I>>(base?: I): HealthCheckRequest {
    return HealthCheckRequest.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheckRequest>, I>>(_: I): HealthCheckRequest {
    const message = createBaseHealthCheckRequest()
    return message
  },
}

function createBaseHealthCheckResponse(): HealthCheckResponse {
  return { status: '', version: '' }
}

export const HealthCheckResponse: MessageFns<HealthCheckResponse> = {
  encode(message: HealthCheckResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== '') {
      writer.uint32(10).string(message.status)
    }
    if (message.version !== '') {
      writer.uint32(18).string(message.version)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseHealthCheckResponse()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.status = reader.string()
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.version = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): HealthCheckResponse {
    return {
      status: isSet(object.status) ? globalThis.String(object.status) : '',
      version: isSet(object.version) ? globalThis.String(object.version) : '',
    }
  },

  toJSON(message: HealthCheckResponse): unknown {
    const obj: any = {}
    if (message.status !== '') {
      obj.status = message.status
    }
    if (message.version !== '') {
      obj.version = message.version
    }
    return obj
  },

  create<I extends Exact<DeepPartial<HealthCheckResponse>, I>>(base?: I): HealthCheckResponse {
    return HealthCheckResponse.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheckResponse>, I>>(object: I): HealthCheckResponse {
    const message = createBaseHealthCheckResponse()
    message.status = object.status ?? ''
    message.version = object.version ?? ''
    return message
  },
}

function createBaseCreateSandboxRequest(): CreateSandboxRequest {
  return {
    id: '',
    fromVolumeId: undefined,
    userId: '',
    image: '',
    osUser: '',
    cpuQuota: 0,
    gpuQuota: 0,
    memoryQuota: 0,
    storageQuota: 0,
    env: {},
    registry: undefined,
    entrypoint: [],
    volumes: [],
  }
}

export const CreateSandboxRequest: MessageFns<CreateSandboxRequest> = {
  encode(message: CreateSandboxRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== '') {
      writer.uint32(10).string(message.id)
    }
    if (message.fromVolumeId !== undefined) {
      writer.uint32(18).string(message.fromVolumeId)
    }
    if (message.userId !== '') {
      writer.uint32(26).string(message.userId)
    }
    if (message.image !== '') {
      writer.uint32(34).string(message.image)
    }
    if (message.osUser !== '') {
      writer.uint32(42).string(message.osUser)
    }
    if (message.cpuQuota !== 0) {
      writer.uint32(48).int64(message.cpuQuota)
    }
    if (message.gpuQuota !== 0) {
      writer.uint32(56).int64(message.gpuQuota)
    }
    if (message.memoryQuota !== 0) {
      writer.uint32(64).int64(message.memoryQuota)
    }
    if (message.storageQuota !== 0) {
      writer.uint32(72).int64(message.storageQuota)
    }
    Object.entries(message.env).forEach(([key, value]) => {
      CreateSandboxRequest_EnvEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join()
    })
    if (message.registry !== undefined) {
      Registry.encode(message.registry, writer.uint32(90).fork()).join()
    }
    for (const v of message.entrypoint) {
      writer.uint32(98).string(v!)
    }
    for (const v of message.volumes) {
      Volume.encode(v!, writer.uint32(106).fork()).join()
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSandboxRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseCreateSandboxRequest()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.id = reader.string()
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.fromVolumeId = reader.string()
          continue
        }
        case 3: {
          if (tag !== 26) {
            break
          }

          message.userId = reader.string()
          continue
        }
        case 4: {
          if (tag !== 34) {
            break
          }

          message.image = reader.string()
          continue
        }
        case 5: {
          if (tag !== 42) {
            break
          }

          message.osUser = reader.string()
          continue
        }
        case 6: {
          if (tag !== 48) {
            break
          }

          message.cpuQuota = longToNumber(reader.int64())
          continue
        }
        case 7: {
          if (tag !== 56) {
            break
          }

          message.gpuQuota = longToNumber(reader.int64())
          continue
        }
        case 8: {
          if (tag !== 64) {
            break
          }

          message.memoryQuota = longToNumber(reader.int64())
          continue
        }
        case 9: {
          if (tag !== 72) {
            break
          }

          message.storageQuota = longToNumber(reader.int64())
          continue
        }
        case 10: {
          if (tag !== 82) {
            break
          }

          const entry10 = CreateSandboxRequest_EnvEntry.decode(reader, reader.uint32())
          if (entry10.value !== undefined) {
            message.env[entry10.key] = entry10.value
          }
          continue
        }
        case 11: {
          if (tag !== 90) {
            break
          }

          message.registry = Registry.decode(reader, reader.uint32())
          continue
        }
        case 12: {
          if (tag !== 98) {
            break
          }

          message.entrypoint.push(reader.string())
          continue
        }
        case 13: {
          if (tag !== 106) {
            break
          }

          message.volumes.push(Volume.decode(reader, reader.uint32()))
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): CreateSandboxRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : '',
      fromVolumeId: isSet(object.fromVolumeId) ? globalThis.String(object.fromVolumeId) : undefined,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      image: isSet(object.image) ? globalThis.String(object.image) : '',
      osUser: isSet(object.osUser) ? globalThis.String(object.osUser) : '',
      cpuQuota: isSet(object.cpuQuota) ? globalThis.Number(object.cpuQuota) : 0,
      gpuQuota: isSet(object.gpuQuota) ? globalThis.Number(object.gpuQuota) : 0,
      memoryQuota: isSet(object.memoryQuota) ? globalThis.Number(object.memoryQuota) : 0,
      storageQuota: isSet(object.storageQuota) ? globalThis.Number(object.storageQuota) : 0,
      env: isObject(object.env)
        ? Object.entries(object.env).reduce<{ [key: string]: string }>((acc, [key, value]) => {
            acc[key] = String(value)
            return acc
          }, {})
        : {},
      registry: isSet(object.registry) ? Registry.fromJSON(object.registry) : undefined,
      entrypoint: globalThis.Array.isArray(object?.entrypoint)
        ? object.entrypoint.map((e: any) => globalThis.String(e))
        : [],
      volumes: globalThis.Array.isArray(object?.volumes) ? object.volumes.map((e: any) => Volume.fromJSON(e)) : [],
    }
  },

  toJSON(message: CreateSandboxRequest): unknown {
    const obj: any = {}
    if (message.id !== '') {
      obj.id = message.id
    }
    if (message.fromVolumeId !== undefined) {
      obj.fromVolumeId = message.fromVolumeId
    }
    if (message.userId !== '') {
      obj.userId = message.userId
    }
    if (message.image !== '') {
      obj.image = message.image
    }
    if (message.osUser !== '') {
      obj.osUser = message.osUser
    }
    if (message.cpuQuota !== 0) {
      obj.cpuQuota = Math.round(message.cpuQuota)
    }
    if (message.gpuQuota !== 0) {
      obj.gpuQuota = Math.round(message.gpuQuota)
    }
    if (message.memoryQuota !== 0) {
      obj.memoryQuota = Math.round(message.memoryQuota)
    }
    if (message.storageQuota !== 0) {
      obj.storageQuota = Math.round(message.storageQuota)
    }
    if (message.env) {
      const entries = Object.entries(message.env)
      if (entries.length > 0) {
        obj.env = {}
        entries.forEach(([k, v]) => {
          obj.env[k] = v
        })
      }
    }
    if (message.registry !== undefined) {
      obj.registry = Registry.toJSON(message.registry)
    }
    if (message.entrypoint?.length) {
      obj.entrypoint = message.entrypoint
    }
    if (message.volumes?.length) {
      obj.volumes = message.volumes.map((e) => Volume.toJSON(e))
    }
    return obj
  },

  create<I extends Exact<DeepPartial<CreateSandboxRequest>, I>>(base?: I): CreateSandboxRequest {
    return CreateSandboxRequest.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<CreateSandboxRequest>, I>>(object: I): CreateSandboxRequest {
    const message = createBaseCreateSandboxRequest()
    message.id = object.id ?? ''
    message.fromVolumeId = object.fromVolumeId ?? undefined
    message.userId = object.userId ?? ''
    message.image = object.image ?? ''
    message.osUser = object.osUser ?? ''
    message.cpuQuota = object.cpuQuota ?? 0
    message.gpuQuota = object.gpuQuota ?? 0
    message.memoryQuota = object.memoryQuota ?? 0
    message.storageQuota = object.storageQuota ?? 0
    message.env = Object.entries(object.env ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value)
      }
      return acc
    }, {})
    message.registry =
      object.registry !== undefined && object.registry !== null ? Registry.fromPartial(object.registry) : undefined
    message.entrypoint = object.entrypoint?.map((e) => e) || []
    message.volumes = object.volumes?.map((e) => Volume.fromPartial(e)) || []
    return message
  },
}

function createBaseCreateSandboxRequest_EnvEntry(): CreateSandboxRequest_EnvEntry {
  return { key: '', value: '' }
}

export const CreateSandboxRequest_EnvEntry: MessageFns<CreateSandboxRequest_EnvEntry> = {
  encode(message: CreateSandboxRequest_EnvEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== '') {
      writer.uint32(10).string(message.key)
    }
    if (message.value !== '') {
      writer.uint32(18).string(message.value)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSandboxRequest_EnvEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseCreateSandboxRequest_EnvEntry()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.key = reader.string()
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.value = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): CreateSandboxRequest_EnvEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : '',
      value: isSet(object.value) ? globalThis.String(object.value) : '',
    }
  },

  toJSON(message: CreateSandboxRequest_EnvEntry): unknown {
    const obj: any = {}
    if (message.key !== '') {
      obj.key = message.key
    }
    if (message.value !== '') {
      obj.value = message.value
    }
    return obj
  },

  create<I extends Exact<DeepPartial<CreateSandboxRequest_EnvEntry>, I>>(base?: I): CreateSandboxRequest_EnvEntry {
    return CreateSandboxRequest_EnvEntry.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<CreateSandboxRequest_EnvEntry>, I>>(
    object: I,
  ): CreateSandboxRequest_EnvEntry {
    const message = createBaseCreateSandboxRequest_EnvEntry()
    message.key = object.key ?? ''
    message.value = object.value ?? ''
    return message
  },
}

function createBaseCreateSandboxResponse(): CreateSandboxResponse {
  return { sandboxId: '' }
}

export const CreateSandboxResponse: MessageFns<CreateSandboxResponse> = {
  encode(message: CreateSandboxResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sandboxId !== '') {
      writer.uint32(10).string(message.sandboxId)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSandboxResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseCreateSandboxResponse()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.sandboxId = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): CreateSandboxResponse {
    return { sandboxId: isSet(object.sandboxId) ? globalThis.String(object.sandboxId) : '' }
  },

  toJSON(message: CreateSandboxResponse): unknown {
    const obj: any = {}
    if (message.sandboxId !== '') {
      obj.sandboxId = message.sandboxId
    }
    return obj
  },

  create<I extends Exact<DeepPartial<CreateSandboxResponse>, I>>(base?: I): CreateSandboxResponse {
    return CreateSandboxResponse.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<CreateSandboxResponse>, I>>(object: I): CreateSandboxResponse {
    const message = createBaseCreateSandboxResponse()
    message.sandboxId = object.sandboxId ?? ''
    return message
  },
}

function createBaseDestroySandboxRequest(): DestroySandboxRequest {
  return { sandboxId: '' }
}

export const DestroySandboxRequest: MessageFns<DestroySandboxRequest> = {
  encode(message: DestroySandboxRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sandboxId !== '') {
      writer.uint32(10).string(message.sandboxId)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DestroySandboxRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseDestroySandboxRequest()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.sandboxId = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): DestroySandboxRequest {
    return { sandboxId: isSet(object.sandboxId) ? globalThis.String(object.sandboxId) : '' }
  },

  toJSON(message: DestroySandboxRequest): unknown {
    const obj: any = {}
    if (message.sandboxId !== '') {
      obj.sandboxId = message.sandboxId
    }
    return obj
  },

  create<I extends Exact<DeepPartial<DestroySandboxRequest>, I>>(base?: I): DestroySandboxRequest {
    return DestroySandboxRequest.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<DestroySandboxRequest>, I>>(object: I): DestroySandboxRequest {
    const message = createBaseDestroySandboxRequest()
    message.sandboxId = object.sandboxId ?? ''
    return message
  },
}

function createBaseDestroySandboxResponse(): DestroySandboxResponse {
  return { message: '' }
}

export const DestroySandboxResponse: MessageFns<DestroySandboxResponse> = {
  encode(message: DestroySandboxResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== '') {
      writer.uint32(10).string(message.message)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DestroySandboxResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseDestroySandboxResponse()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.message = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): DestroySandboxResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : '' }
  },

  toJSON(message: DestroySandboxResponse): unknown {
    const obj: any = {}
    if (message.message !== '') {
      obj.message = message.message
    }
    return obj
  },

  create<I extends Exact<DeepPartial<DestroySandboxResponse>, I>>(base?: I): DestroySandboxResponse {
    return DestroySandboxResponse.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<DestroySandboxResponse>, I>>(object: I): DestroySandboxResponse {
    const message = createBaseDestroySandboxResponse()
    message.message = object.message ?? ''
    return message
  },
}

function createBaseCreateSnapshotRequest(): CreateSnapshotRequest {
  return { sandboxId: '', registry: undefined, image: '' }
}

export const CreateSnapshotRequest: MessageFns<CreateSnapshotRequest> = {
  encode(message: CreateSnapshotRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sandboxId !== '') {
      writer.uint32(10).string(message.sandboxId)
    }
    if (message.registry !== undefined) {
      Registry.encode(message.registry, writer.uint32(18).fork()).join()
    }
    if (message.image !== '') {
      writer.uint32(26).string(message.image)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSnapshotRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseCreateSnapshotRequest()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.sandboxId = reader.string()
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.registry = Registry.decode(reader, reader.uint32())
          continue
        }
        case 3: {
          if (tag !== 26) {
            break
          }

          message.image = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): CreateSnapshotRequest {
    return {
      sandboxId: isSet(object.sandboxId) ? globalThis.String(object.sandboxId) : '',
      registry: isSet(object.registry) ? Registry.fromJSON(object.registry) : undefined,
      image: isSet(object.image) ? globalThis.String(object.image) : '',
    }
  },

  toJSON(message: CreateSnapshotRequest): unknown {
    const obj: any = {}
    if (message.sandboxId !== '') {
      obj.sandboxId = message.sandboxId
    }
    if (message.registry !== undefined) {
      obj.registry = Registry.toJSON(message.registry)
    }
    if (message.image !== '') {
      obj.image = message.image
    }
    return obj
  },

  create<I extends Exact<DeepPartial<CreateSnapshotRequest>, I>>(base?: I): CreateSnapshotRequest {
    return CreateSnapshotRequest.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<CreateSnapshotRequest>, I>>(object: I): CreateSnapshotRequest {
    const message = createBaseCreateSnapshotRequest()
    message.sandboxId = object.sandboxId ?? ''
    message.registry =
      object.registry !== undefined && object.registry !== null ? Registry.fromPartial(object.registry) : undefined
    message.image = object.image ?? ''
    return message
  },
}

function createBaseCreateSnapshotResponse(): CreateSnapshotResponse {
  return { message: '' }
}

export const CreateSnapshotResponse: MessageFns<CreateSnapshotResponse> = {
  encode(message: CreateSnapshotResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== '') {
      writer.uint32(10).string(message.message)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSnapshotResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseCreateSnapshotResponse()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.message = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): CreateSnapshotResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : '' }
  },

  toJSON(message: CreateSnapshotResponse): unknown {
    const obj: any = {}
    if (message.message !== '') {
      obj.message = message.message
    }
    return obj
  },

  create<I extends Exact<DeepPartial<CreateSnapshotResponse>, I>>(base?: I): CreateSnapshotResponse {
    return CreateSnapshotResponse.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<CreateSnapshotResponse>, I>>(object: I): CreateSnapshotResponse {
    const message = createBaseCreateSnapshotResponse()
    message.message = object.message ?? ''
    return message
  },
}

function createBaseStartSandboxRequest(): StartSandboxRequest {
  return { sandboxId: '' }
}

export const StartSandboxRequest: MessageFns<StartSandboxRequest> = {
  encode(message: StartSandboxRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sandboxId !== '') {
      writer.uint32(10).string(message.sandboxId)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartSandboxRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseStartSandboxRequest()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.sandboxId = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): StartSandboxRequest {
    return { sandboxId: isSet(object.sandboxId) ? globalThis.String(object.sandboxId) : '' }
  },

  toJSON(message: StartSandboxRequest): unknown {
    const obj: any = {}
    if (message.sandboxId !== '') {
      obj.sandboxId = message.sandboxId
    }
    return obj
  },

  create<I extends Exact<DeepPartial<StartSandboxRequest>, I>>(base?: I): StartSandboxRequest {
    return StartSandboxRequest.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<StartSandboxRequest>, I>>(object: I): StartSandboxRequest {
    const message = createBaseStartSandboxRequest()
    message.sandboxId = object.sandboxId ?? ''
    return message
  },
}

function createBaseStartSandboxResponse(): StartSandboxResponse {
  return { message: '' }
}

export const StartSandboxResponse: MessageFns<StartSandboxResponse> = {
  encode(message: StartSandboxResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== '') {
      writer.uint32(10).string(message.message)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartSandboxResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseStartSandboxResponse()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.message = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): StartSandboxResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : '' }
  },

  toJSON(message: StartSandboxResponse): unknown {
    const obj: any = {}
    if (message.message !== '') {
      obj.message = message.message
    }
    return obj
  },

  create<I extends Exact<DeepPartial<StartSandboxResponse>, I>>(base?: I): StartSandboxResponse {
    return StartSandboxResponse.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<StartSandboxResponse>, I>>(object: I): StartSandboxResponse {
    const message = createBaseStartSandboxResponse()
    message.message = object.message ?? ''
    return message
  },
}

function createBaseStopSandboxRequest(): StopSandboxRequest {
  return { sandboxId: '' }
}

export const StopSandboxRequest: MessageFns<StopSandboxRequest> = {
  encode(message: StopSandboxRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sandboxId !== '') {
      writer.uint32(10).string(message.sandboxId)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StopSandboxRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseStopSandboxRequest()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.sandboxId = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): StopSandboxRequest {
    return { sandboxId: isSet(object.sandboxId) ? globalThis.String(object.sandboxId) : '' }
  },

  toJSON(message: StopSandboxRequest): unknown {
    const obj: any = {}
    if (message.sandboxId !== '') {
      obj.sandboxId = message.sandboxId
    }
    return obj
  },

  create<I extends Exact<DeepPartial<StopSandboxRequest>, I>>(base?: I): StopSandboxRequest {
    return StopSandboxRequest.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<StopSandboxRequest>, I>>(object: I): StopSandboxRequest {
    const message = createBaseStopSandboxRequest()
    message.sandboxId = object.sandboxId ?? ''
    return message
  },
}

function createBaseStopSandboxResponse(): StopSandboxResponse {
  return { message: '' }
}

export const StopSandboxResponse: MessageFns<StopSandboxResponse> = {
  encode(message: StopSandboxResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== '') {
      writer.uint32(10).string(message.message)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StopSandboxResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseStopSandboxResponse()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.message = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): StopSandboxResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : '' }
  },

  toJSON(message: StopSandboxResponse): unknown {
    const obj: any = {}
    if (message.message !== '') {
      obj.message = message.message
    }
    return obj
  },

  create<I extends Exact<DeepPartial<StopSandboxResponse>, I>>(base?: I): StopSandboxResponse {
    return StopSandboxResponse.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<StopSandboxResponse>, I>>(object: I): StopSandboxResponse {
    const message = createBaseStopSandboxResponse()
    message.message = object.message ?? ''
    return message
  },
}

function createBaseGetSandboxInfoRequest(): GetSandboxInfoRequest {
  return { sandboxId: '' }
}

export const GetSandboxInfoRequest: MessageFns<GetSandboxInfoRequest> = {
  encode(message: GetSandboxInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sandboxId !== '') {
      writer.uint32(10).string(message.sandboxId)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSandboxInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseGetSandboxInfoRequest()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.sandboxId = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): GetSandboxInfoRequest {
    return { sandboxId: isSet(object.sandboxId) ? globalThis.String(object.sandboxId) : '' }
  },

  toJSON(message: GetSandboxInfoRequest): unknown {
    const obj: any = {}
    if (message.sandboxId !== '') {
      obj.sandboxId = message.sandboxId
    }
    return obj
  },

  create<I extends Exact<DeepPartial<GetSandboxInfoRequest>, I>>(base?: I): GetSandboxInfoRequest {
    return GetSandboxInfoRequest.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<GetSandboxInfoRequest>, I>>(object: I): GetSandboxInfoRequest {
    const message = createBaseGetSandboxInfoRequest()
    message.sandboxId = object.sandboxId ?? ''
    return message
  },
}

function createBaseGetSandboxInfoResponse(): GetSandboxInfoResponse {
  return { state: '', snapshotState: '' }
}

export const GetSandboxInfoResponse: MessageFns<GetSandboxInfoResponse> = {
  encode(message: GetSandboxInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== '') {
      writer.uint32(10).string(message.state)
    }
    if (message.snapshotState !== '') {
      writer.uint32(18).string(message.snapshotState)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSandboxInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseGetSandboxInfoResponse()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.state = reader.string()
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.snapshotState = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): GetSandboxInfoResponse {
    return {
      state: isSet(object.state) ? globalThis.String(object.state) : '',
      snapshotState: isSet(object.snapshotState) ? globalThis.String(object.snapshotState) : '',
    }
  },

  toJSON(message: GetSandboxInfoResponse): unknown {
    const obj: any = {}
    if (message.state !== '') {
      obj.state = message.state
    }
    if (message.snapshotState !== '') {
      obj.snapshotState = message.snapshotState
    }
    return obj
  },

  create<I extends Exact<DeepPartial<GetSandboxInfoResponse>, I>>(base?: I): GetSandboxInfoResponse {
    return GetSandboxInfoResponse.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<GetSandboxInfoResponse>, I>>(object: I): GetSandboxInfoResponse {
    const message = createBaseGetSandboxInfoResponse()
    message.state = object.state ?? ''
    message.snapshotState = object.snapshotState ?? ''
    return message
  },
}

function createBaseRemoveDestroyedSandboxRequest(): RemoveDestroyedSandboxRequest {
  return { sandboxId: '' }
}

export const RemoveDestroyedSandboxRequest: MessageFns<RemoveDestroyedSandboxRequest> = {
  encode(message: RemoveDestroyedSandboxRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sandboxId !== '') {
      writer.uint32(10).string(message.sandboxId)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveDestroyedSandboxRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseRemoveDestroyedSandboxRequest()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.sandboxId = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): RemoveDestroyedSandboxRequest {
    return { sandboxId: isSet(object.sandboxId) ? globalThis.String(object.sandboxId) : '' }
  },

  toJSON(message: RemoveDestroyedSandboxRequest): unknown {
    const obj: any = {}
    if (message.sandboxId !== '') {
      obj.sandboxId = message.sandboxId
    }
    return obj
  },

  create<I extends Exact<DeepPartial<RemoveDestroyedSandboxRequest>, I>>(base?: I): RemoveDestroyedSandboxRequest {
    return RemoveDestroyedSandboxRequest.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<RemoveDestroyedSandboxRequest>, I>>(
    object: I,
  ): RemoveDestroyedSandboxRequest {
    const message = createBaseRemoveDestroyedSandboxRequest()
    message.sandboxId = object.sandboxId ?? ''
    return message
  },
}

function createBaseRemoveDestroyedSandboxResponse(): RemoveDestroyedSandboxResponse {
  return { message: '' }
}

export const RemoveDestroyedSandboxResponse: MessageFns<RemoveDestroyedSandboxResponse> = {
  encode(message: RemoveDestroyedSandboxResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== '') {
      writer.uint32(10).string(message.message)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveDestroyedSandboxResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseRemoveDestroyedSandboxResponse()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.message = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): RemoveDestroyedSandboxResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : '' }
  },

  toJSON(message: RemoveDestroyedSandboxResponse): unknown {
    const obj: any = {}
    if (message.message !== '') {
      obj.message = message.message
    }
    return obj
  },

  create<I extends Exact<DeepPartial<RemoveDestroyedSandboxResponse>, I>>(base?: I): RemoveDestroyedSandboxResponse {
    return RemoveDestroyedSandboxResponse.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<RemoveDestroyedSandboxResponse>, I>>(
    object: I,
  ): RemoveDestroyedSandboxResponse {
    const message = createBaseRemoveDestroyedSandboxResponse()
    message.message = object.message ?? ''
    return message
  },
}

function createBaseRegistry(): Registry {
  return { url: '', project: undefined, username: undefined, password: undefined }
}

export const Registry: MessageFns<Registry> = {
  encode(message: Registry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== '') {
      writer.uint32(10).string(message.url)
    }
    if (message.project !== undefined) {
      writer.uint32(18).string(message.project)
    }
    if (message.username !== undefined) {
      writer.uint32(26).string(message.username)
    }
    if (message.password !== undefined) {
      writer.uint32(34).string(message.password)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Registry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseRegistry()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.url = reader.string()
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.project = reader.string()
          continue
        }
        case 3: {
          if (tag !== 26) {
            break
          }

          message.username = reader.string()
          continue
        }
        case 4: {
          if (tag !== 34) {
            break
          }

          message.password = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): Registry {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : '',
      project: isSet(object.project) ? globalThis.String(object.project) : undefined,
      username: isSet(object.username) ? globalThis.String(object.username) : undefined,
      password: isSet(object.password) ? globalThis.String(object.password) : undefined,
    }
  },

  toJSON(message: Registry): unknown {
    const obj: any = {}
    if (message.url !== '') {
      obj.url = message.url
    }
    if (message.project !== undefined) {
      obj.project = message.project
    }
    if (message.username !== undefined) {
      obj.username = message.username
    }
    if (message.password !== undefined) {
      obj.password = message.password
    }
    return obj
  },

  create<I extends Exact<DeepPartial<Registry>, I>>(base?: I): Registry {
    return Registry.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<Registry>, I>>(object: I): Registry {
    const message = createBaseRegistry()
    message.url = object.url ?? ''
    message.project = object.project ?? undefined
    message.username = object.username ?? undefined
    message.password = object.password ?? undefined
    return message
  },
}

function createBasePullImageRequest(): PullImageRequest {
  return { image: '', registry: undefined }
}

export const PullImageRequest: MessageFns<PullImageRequest> = {
  encode(message: PullImageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.image !== '') {
      writer.uint32(10).string(message.image)
    }
    if (message.registry !== undefined) {
      Registry.encode(message.registry, writer.uint32(18).fork()).join()
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PullImageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBasePullImageRequest()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.image = reader.string()
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.registry = Registry.decode(reader, reader.uint32())
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): PullImageRequest {
    return {
      image: isSet(object.image) ? globalThis.String(object.image) : '',
      registry: isSet(object.registry) ? Registry.fromJSON(object.registry) : undefined,
    }
  },

  toJSON(message: PullImageRequest): unknown {
    const obj: any = {}
    if (message.image !== '') {
      obj.image = message.image
    }
    if (message.registry !== undefined) {
      obj.registry = Registry.toJSON(message.registry)
    }
    return obj
  },

  create<I extends Exact<DeepPartial<PullImageRequest>, I>>(base?: I): PullImageRequest {
    return PullImageRequest.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<PullImageRequest>, I>>(object: I): PullImageRequest {
    const message = createBasePullImageRequest()
    message.image = object.image ?? ''
    message.registry =
      object.registry !== undefined && object.registry !== null ? Registry.fromPartial(object.registry) : undefined
    return message
  },
}

function createBasePullImageResponse(): PullImageResponse {
  return { message: '' }
}

export const PullImageResponse: MessageFns<PullImageResponse> = {
  encode(message: PullImageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== '') {
      writer.uint32(10).string(message.message)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PullImageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBasePullImageResponse()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.message = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): PullImageResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : '' }
  },

  toJSON(message: PullImageResponse): unknown {
    const obj: any = {}
    if (message.message !== '') {
      obj.message = message.message
    }
    return obj
  },

  create<I extends Exact<DeepPartial<PullImageResponse>, I>>(base?: I): PullImageResponse {
    return PullImageResponse.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<PullImageResponse>, I>>(object: I): PullImageResponse {
    const message = createBasePullImageResponse()
    message.message = object.message ?? ''
    return message
  },
}

function createBaseBuildImageRequest(): BuildImageRequest {
  return {
    image: undefined,
    registry: undefined,
    dockerfile: '',
    organizationId: '',
    context: [],
    pushToInternalRegistry: undefined,
  }
}

export const BuildImageRequest: MessageFns<BuildImageRequest> = {
  encode(message: BuildImageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.image !== undefined) {
      writer.uint32(10).string(message.image)
    }
    if (message.registry !== undefined) {
      Registry.encode(message.registry, writer.uint32(18).fork()).join()
    }
    if (message.dockerfile !== '') {
      writer.uint32(26).string(message.dockerfile)
    }
    if (message.organizationId !== '') {
      writer.uint32(34).string(message.organizationId)
    }
    for (const v of message.context) {
      writer.uint32(42).string(v!)
    }
    if (message.pushToInternalRegistry !== undefined) {
      writer.uint32(48).bool(message.pushToInternalRegistry)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildImageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseBuildImageRequest()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.image = reader.string()
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.registry = Registry.decode(reader, reader.uint32())
          continue
        }
        case 3: {
          if (tag !== 26) {
            break
          }

          message.dockerfile = reader.string()
          continue
        }
        case 4: {
          if (tag !== 34) {
            break
          }

          message.organizationId = reader.string()
          continue
        }
        case 5: {
          if (tag !== 42) {
            break
          }

          message.context.push(reader.string())
          continue
        }
        case 6: {
          if (tag !== 48) {
            break
          }

          message.pushToInternalRegistry = reader.bool()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): BuildImageRequest {
    return {
      image: isSet(object.image) ? globalThis.String(object.image) : undefined,
      registry: isSet(object.registry) ? Registry.fromJSON(object.registry) : undefined,
      dockerfile: isSet(object.dockerfile) ? globalThis.String(object.dockerfile) : '',
      organizationId: isSet(object.organizationId) ? globalThis.String(object.organizationId) : '',
      context: globalThis.Array.isArray(object?.context) ? object.context.map((e: any) => globalThis.String(e)) : [],
      pushToInternalRegistry: isSet(object.pushToInternalRegistry)
        ? globalThis.Boolean(object.pushToInternalRegistry)
        : undefined,
    }
  },

  toJSON(message: BuildImageRequest): unknown {
    const obj: any = {}
    if (message.image !== undefined) {
      obj.image = message.image
    }
    if (message.registry !== undefined) {
      obj.registry = Registry.toJSON(message.registry)
    }
    if (message.dockerfile !== '') {
      obj.dockerfile = message.dockerfile
    }
    if (message.organizationId !== '') {
      obj.organizationId = message.organizationId
    }
    if (message.context?.length) {
      obj.context = message.context
    }
    if (message.pushToInternalRegistry !== undefined) {
      obj.pushToInternalRegistry = message.pushToInternalRegistry
    }
    return obj
  },

  create<I extends Exact<DeepPartial<BuildImageRequest>, I>>(base?: I): BuildImageRequest {
    return BuildImageRequest.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<BuildImageRequest>, I>>(object: I): BuildImageRequest {
    const message = createBaseBuildImageRequest()
    message.image = object.image ?? undefined
    message.registry =
      object.registry !== undefined && object.registry !== null ? Registry.fromPartial(object.registry) : undefined
    message.dockerfile = object.dockerfile ?? ''
    message.organizationId = object.organizationId ?? ''
    message.context = object.context?.map((e) => e) || []
    message.pushToInternalRegistry = object.pushToInternalRegistry ?? undefined
    return message
  },
}

function createBaseBuildImageResponse(): BuildImageResponse {
  return { message: '' }
}

export const BuildImageResponse: MessageFns<BuildImageResponse> = {
  encode(message: BuildImageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== '') {
      writer.uint32(10).string(message.message)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildImageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseBuildImageResponse()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.message = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): BuildImageResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : '' }
  },

  toJSON(message: BuildImageResponse): unknown {
    const obj: any = {}
    if (message.message !== '') {
      obj.message = message.message
    }
    return obj
  },

  create<I extends Exact<DeepPartial<BuildImageResponse>, I>>(base?: I): BuildImageResponse {
    return BuildImageResponse.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<BuildImageResponse>, I>>(object: I): BuildImageResponse {
    const message = createBaseBuildImageResponse()
    message.message = object.message ?? ''
    return message
  },
}

function createBaseImageExistsRequest(): ImageExistsRequest {
  return { image: '', includeLatest: false }
}

export const ImageExistsRequest: MessageFns<ImageExistsRequest> = {
  encode(message: ImageExistsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.image !== '') {
      writer.uint32(10).string(message.image)
    }
    if (message.includeLatest !== false) {
      writer.uint32(16).bool(message.includeLatest)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageExistsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseImageExistsRequest()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.image = reader.string()
          continue
        }
        case 2: {
          if (tag !== 16) {
            break
          }

          message.includeLatest = reader.bool()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): ImageExistsRequest {
    return {
      image: isSet(object.image) ? globalThis.String(object.image) : '',
      includeLatest: isSet(object.includeLatest) ? globalThis.Boolean(object.includeLatest) : false,
    }
  },

  toJSON(message: ImageExistsRequest): unknown {
    const obj: any = {}
    if (message.image !== '') {
      obj.image = message.image
    }
    if (message.includeLatest !== false) {
      obj.includeLatest = message.includeLatest
    }
    return obj
  },

  create<I extends Exact<DeepPartial<ImageExistsRequest>, I>>(base?: I): ImageExistsRequest {
    return ImageExistsRequest.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<ImageExistsRequest>, I>>(object: I): ImageExistsRequest {
    const message = createBaseImageExistsRequest()
    message.image = object.image ?? ''
    message.includeLatest = object.includeLatest ?? false
    return message
  },
}

function createBaseImageExistsResponse(): ImageExistsResponse {
  return { exists: false }
}

export const ImageExistsResponse: MessageFns<ImageExistsResponse> = {
  encode(message: ImageExistsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.exists !== false) {
      writer.uint32(8).bool(message.exists)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageExistsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseImageExistsResponse()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break
          }

          message.exists = reader.bool()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): ImageExistsResponse {
    return { exists: isSet(object.exists) ? globalThis.Boolean(object.exists) : false }
  },

  toJSON(message: ImageExistsResponse): unknown {
    const obj: any = {}
    if (message.exists !== false) {
      obj.exists = message.exists
    }
    return obj
  },

  create<I extends Exact<DeepPartial<ImageExistsResponse>, I>>(base?: I): ImageExistsResponse {
    return ImageExistsResponse.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<ImageExistsResponse>, I>>(object: I): ImageExistsResponse {
    const message = createBaseImageExistsResponse()
    message.exists = object.exists ?? false
    return message
  },
}

function createBaseRemoveImageRequest(): RemoveImageRequest {
  return { image: '', force: false }
}

export const RemoveImageRequest: MessageFns<RemoveImageRequest> = {
  encode(message: RemoveImageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.image !== '') {
      writer.uint32(10).string(message.image)
    }
    if (message.force !== false) {
      writer.uint32(16).bool(message.force)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveImageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseRemoveImageRequest()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.image = reader.string()
          continue
        }
        case 2: {
          if (tag !== 16) {
            break
          }

          message.force = reader.bool()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): RemoveImageRequest {
    return {
      image: isSet(object.image) ? globalThis.String(object.image) : '',
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    }
  },

  toJSON(message: RemoveImageRequest): unknown {
    const obj: any = {}
    if (message.image !== '') {
      obj.image = message.image
    }
    if (message.force !== false) {
      obj.force = message.force
    }
    return obj
  },

  create<I extends Exact<DeepPartial<RemoveImageRequest>, I>>(base?: I): RemoveImageRequest {
    return RemoveImageRequest.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<RemoveImageRequest>, I>>(object: I): RemoveImageRequest {
    const message = createBaseRemoveImageRequest()
    message.image = object.image ?? ''
    message.force = object.force ?? false
    return message
  },
}

function createBaseRemoveImageResponse(): RemoveImageResponse {
  return { message: '' }
}

export const RemoveImageResponse: MessageFns<RemoveImageResponse> = {
  encode(message: RemoveImageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== '') {
      writer.uint32(10).string(message.message)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveImageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseRemoveImageResponse()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.message = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): RemoveImageResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : '' }
  },

  toJSON(message: RemoveImageResponse): unknown {
    const obj: any = {}
    if (message.message !== '') {
      obj.message = message.message
    }
    return obj
  },

  create<I extends Exact<DeepPartial<RemoveImageResponse>, I>>(base?: I): RemoveImageResponse {
    return RemoveImageResponse.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<RemoveImageResponse>, I>>(object: I): RemoveImageResponse {
    const message = createBaseRemoveImageResponse()
    message.message = object.message ?? ''
    return message
  },
}

function createBaseBuildLogsRequest(): BuildLogsRequest {
  return { imageRef: '', follow: false }
}

export const BuildLogsRequest: MessageFns<BuildLogsRequest> = {
  encode(message: BuildLogsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.imageRef !== '') {
      writer.uint32(10).string(message.imageRef)
    }
    if (message.follow !== false) {
      writer.uint32(16).bool(message.follow)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildLogsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseBuildLogsRequest()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.imageRef = reader.string()
          continue
        }
        case 2: {
          if (tag !== 16) {
            break
          }

          message.follow = reader.bool()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): BuildLogsRequest {
    return {
      imageRef: isSet(object.imageRef) ? globalThis.String(object.imageRef) : '',
      follow: isSet(object.follow) ? globalThis.Boolean(object.follow) : false,
    }
  },

  toJSON(message: BuildLogsRequest): unknown {
    const obj: any = {}
    if (message.imageRef !== '') {
      obj.imageRef = message.imageRef
    }
    if (message.follow !== false) {
      obj.follow = message.follow
    }
    return obj
  },

  create<I extends Exact<DeepPartial<BuildLogsRequest>, I>>(base?: I): BuildLogsRequest {
    return BuildLogsRequest.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<BuildLogsRequest>, I>>(object: I): BuildLogsRequest {
    const message = createBaseBuildLogsRequest()
    message.imageRef = object.imageRef ?? ''
    message.follow = object.follow ?? false
    return message
  },
}

function createBaseBuildLogsResponse(): BuildLogsResponse {
  return { data: new Uint8Array(0) }
}

export const BuildLogsResponse: MessageFns<BuildLogsResponse> = {
  encode(message: BuildLogsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildLogsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseBuildLogsResponse()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.data = reader.bytes()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): BuildLogsResponse {
    return { data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0) }
  },

  toJSON(message: BuildLogsResponse): unknown {
    const obj: any = {}
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data)
    }
    return obj
  },

  create<I extends Exact<DeepPartial<BuildLogsResponse>, I>>(base?: I): BuildLogsResponse {
    return BuildLogsResponse.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<BuildLogsResponse>, I>>(object: I): BuildLogsResponse {
    const message = createBaseBuildLogsResponse()
    message.data = object.data ?? new Uint8Array(0)
    return message
  },
}

function createBaseVolume(): Volume {
  return { volumeId: '', mountPath: '' }
}

export const Volume: MessageFns<Volume> = {
  encode(message: Volume, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.volumeId !== '') {
      writer.uint32(10).string(message.volumeId)
    }
    if (message.mountPath !== '') {
      writer.uint32(18).string(message.mountPath)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Volume {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseVolume()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.volumeId = reader.string()
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.mountPath = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): Volume {
    return {
      volumeId: isSet(object.volumeId) ? globalThis.String(object.volumeId) : '',
      mountPath: isSet(object.mountPath) ? globalThis.String(object.mountPath) : '',
    }
  },

  toJSON(message: Volume): unknown {
    const obj: any = {}
    if (message.volumeId !== '') {
      obj.volumeId = message.volumeId
    }
    if (message.mountPath !== '') {
      obj.mountPath = message.mountPath
    }
    return obj
  },

  create<I extends Exact<DeepPartial<Volume>, I>>(base?: I): Volume {
    return Volume.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<Volume>, I>>(object: I): Volume {
    const message = createBaseVolume()
    message.volumeId = object.volumeId ?? ''
    message.mountPath = object.mountPath ?? ''
    return message
  },
}

export interface RunnerServiceImplementation<CallContextExt = {}> {
  /** Health endpoints */
  healthCheck(
    request: HealthCheckRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<HealthCheckResponse>>
  /** Sandbox endpoints */
  createSandbox(
    request: CreateSandboxRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CreateSandboxResponse>>
  destroySandbox(
    request: DestroySandboxRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<DestroySandboxResponse>>
  createSnapshot(
    request: CreateSnapshotRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CreateSnapshotResponse>>
  startSandbox(
    request: StartSandboxRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<StartSandboxResponse>>
  stopSandbox(
    request: StopSandboxRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<StopSandboxResponse>>
  getSandboxInfo(
    request: GetSandboxInfoRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetSandboxInfoResponse>>
  removeDestroyedSandbox(
    request: RemoveDestroyedSandboxRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<RemoveDestroyedSandboxResponse>>
  /** Image endpoints */
  pullImage(request: PullImageRequest, context: CallContext & CallContextExt): Promise<DeepPartial<PullImageResponse>>
  buildImage(
    request: BuildImageRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<BuildImageResponse>>
  imageExists(
    request: ImageExistsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ImageExistsResponse>>
  removeImage(
    request: RemoveImageRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<RemoveImageResponse>>
  buildLogs(
    request: BuildLogsRequest,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<BuildLogsResponse>>
}

export interface RunnerClient<CallOptionsExt = {}> {
  /** Health endpoints */
  healthCheck(
    request: DeepPartial<HealthCheckRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<HealthCheckResponse>
  /** Sandbox endpoints */
  createSandbox(
    request: DeepPartial<CreateSandboxRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CreateSandboxResponse>
  destroySandbox(
    request: DeepPartial<DestroySandboxRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DestroySandboxResponse>
  createSnapshot(
    request: DeepPartial<CreateSnapshotRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CreateSnapshotResponse>
  startSandbox(
    request: DeepPartial<StartSandboxRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<StartSandboxResponse>
  stopSandbox(
    request: DeepPartial<StopSandboxRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<StopSandboxResponse>
  getSandboxInfo(
    request: DeepPartial<GetSandboxInfoRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetSandboxInfoResponse>
  removeDestroyedSandbox(
    request: DeepPartial<RemoveDestroyedSandboxRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<RemoveDestroyedSandboxResponse>
  /** Image endpoints */
  pullImage(request: DeepPartial<PullImageRequest>, options?: CallOptions & CallOptionsExt): Promise<PullImageResponse>
  buildImage(
    request: DeepPartial<BuildImageRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<BuildImageResponse>
  imageExists(
    request: DeepPartial<ImageExistsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ImageExistsResponse>
  removeImage(
    request: DeepPartial<RemoveImageRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<RemoveImageResponse>
  buildLogs(
    request: DeepPartial<BuildLogsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<BuildLogsResponse>
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, 'base64'))
  } else {
    const bin = globalThis.atob(b64)
    const arr = new Uint8Array(bin.length)
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i)
    }
    return arr
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString('base64')
  } else {
    const bin: string[] = []
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte))
    })
    return globalThis.btoa(bin.join(''))
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>

type KeysOfUnion<T> = T extends T ? keyof T : never
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never }

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString())
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error('Value is larger than Number.MAX_SAFE_INTEGER')
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error('Value is smaller than Number.MIN_SAFE_INTEGER')
  }
  return num
}

function isObject(value: any): boolean {
  return typeof value === 'object' && value !== null
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined
}

export type ServerStreamingMethodResult<Response> = { [Symbol.asyncIterator](): AsyncIterator<Response, void> }

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter
  decode(input: BinaryReader | Uint8Array, length?: number): T
  fromJSON(object: any): T
  toJSON(message: T): unknown
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T
}
